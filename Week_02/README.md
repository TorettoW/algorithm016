### 一、STL的map  
    1、STL中，map对应的数据结构是红黑树，unordered_map对应的是哈希表。  
    2、unordered_map的查找时间复杂度为常数级别O（1），空间复杂度则要高一些。map的查找操作就是红黑树的查找操作时间复杂度O（logN）。  
       对于需要高效率查询的情况，使用 unordered_map 容器。而如果对内存大小比较敏感或者数据存储要求有序的话，则可以用 map 容器。
    3、stl::map对于与java中的TreeMap，而boost::unordered_map对应于java中的HashMap
### 二、树的定义
    树的递归定义：一定注意是左子树和右子树，而不是左儿子和右儿子。  
    要掌握二叉树和N叉树的前/中/后序遍历（栈的解法）
### 三、STL的heap  
    heap是一棵完全二叉树，在STL中，heap是算法的形式提供给我们使用的。包括下面几个函数：  
    1）make_heap: 根据指定的迭代器区间以及一个可选的比较函数，来创建一个heap. O(N)  
    2）push_heap: 把指定区间的最后一个元素插入到heap中. O(logN)  
    3）pop_heap: 弹出heap顶元素, 将其放置于区间末尾. O(logN)  
    4）sort_heap：堆排序算法，通常通过反复调用pop_heap来实现. N*O(logN)  
    [heap用法参考](https://www.geeksforgeeks.org/heap-using-stl-c/)  
### 四、图
#### 1.图的存储结构  
     1)邻接矩阵：用一个一维数组存储图中顶点的信息，用一个二维数组（称为邻接矩阵）存储图中各顶点之间的邻接关系。  
     2)邻接表：邻接表存储的基本思想：对于图的每个顶点vi，将所有邻接于vi的顶点链成一个单链表，称为顶点vi的边表（对于有向图则称为出边表），  
       所有边表的头指针和存储顶点信息的一维数组构成了顶点表。  
       邻接表有两种结点结构：顶点表结点和边表结点。  
#### 2.图的遍历  
     1)图的遍历思想是从指定一个顶点出发，开始访问其他顶点，不能重复访问（每个顶点只能访问一次），直至所有点被访问。  
        a.深度优先遍历（depth_first_search）  
        思想：从指定的第一个点开始，沿着向下的定点不重复的一直遍历下去，若走到尽头，退到上一个顶点，寻找附近有没有顶点，有而且不重复的话，接着遍历，否则退到上一个顶点。  
        Step1:把当前图中所有顶点压入栈 （防止有非联通顶点未被遍历）  
        Step2:出发点入栈  
        Step3:读取栈顶，将该顶点标记为“已访问”  
        Step4:把栈顶指向的所有未访问的顶点入栈  
        Step5:重复第3，4步，直到队列为空  
        b.广度优先遍历（breadth_first_search）  
        思想：从指定的第一点开始，先寻找跟它直接相连的所有顶点，然后继续这几个顶点再次深入，每次搜寻的都是同一级别的。 
        Step1:把出发点压入队列  
        Step2:读取队列头，将该顶点标记为“已访问”  
        Step3:把队列头指向的所有未访问的顶点压入队尾  
        Step4:重复第2，3步，直到队列为空  
        Step5:检查图中是否还有顶点未访问 （非连通顶点），如果是，则将该顶点入队列，重复2，3，4，5  
      
    
